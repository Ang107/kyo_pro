一旦真っ新なパレットを考える
このとき，目標のベクトルは，係数が離散化された各ベクトルの和を目標値に近似することと言える

最後の一回の追加のみは係数が連続にできる可能性を秘めている ← これ難しい

また，その時点で，色の種類数をふやすのは頂けないが，かといって量が少なくなりすぎるのも良くない ← これは係数の和が 1 以上とすればよい

出来る操作が少ないケースは別で考えるか
目標の絵具を全探索(i:0~999){
使う絵の具の数の上限を 5 として，
使う絵の具の数[1,2,3,4,5]，係数[0.1,0.2,...1.1...2] を乱択する(iter=1000)
係数の和が 1 以上になるように各係数を調整
そのときの誤差，必要な絵具の量，必要な操作回数を計算
必要な操作回数が (T-1000)/1000 以下であって，
誤差と絵具の量から求められるコストが最小となるような係数列を求める
係数列を山登り(係数の増減)(iter=1000)
係数列を元に操作を構築，出力

}
使う絵の具の数のループ(cnt:1~3){
使う絵の具の種類数を全探索(20 C cnt){
使う絵の具の量の列の全探索([0.1,0.2,...1.1...2] を cnt 回直積){
そのときの誤差，必要な絵具の量，必要な操作回数を計算
必要な操作回数が (T-1000)/1000 以下であって，
誤差と絵具の量から求められるコストが最小となるような使う絵の具の量の列を求める
}
}
}

T を有効に使い切る
maxcolors=1 のケースの改善
特に絵具が高い場合，一気に作ってあとで渡すみたいなやり方が良い
最初に出すだけ出してそれを上手いこと混ぜるみたいな必要がある

乱択，山登り部分の高速化
操作の効率化

T が小さいケースの特殊ソルバー作る
↑ 一応ビムサをできる
チューブの使ってる本数調べる
離散化によるコスト増加量を調べる

特殊ソルバーに力入れてもいいかもなー
一つのウェルをでかくしていい
最初からいくつか色をいれてよい
↑ この辺は試すしかない

ウェルサイズ割り当て適当でよいか

T が大きい場合のソルバー
バイナリ敵に管理する

乱択山登り部分の評価高速化できそう
だいぶ早くなったがまだ伸びしろありそう
温度いじる，温度関数いじる
近傍いじる

乱択はあらかじめ生成しておき，その中から探すのもありか？
生成にかかるコストを減らしつつ

bit 全探索は K が大きいと重いのでその場合は乱宅を使う

計数列生成 → 各目標への距離の最短を探す(それを初期解とする)
焼きなましとか乱宅いらん
もう一つの方が早くて正確
