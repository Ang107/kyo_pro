必ずしも、最初から良い置き方を探しに行く必要は無い
最初は今のアイテムの大きさの推定に徹するのもあり
こういう置き方をしたときに、得られる情報量が多いよね、というような置き方を繰り返すことで、
効率よく、それぞれの大きさを絞り、良い置き方を見つけたい
正規の値の範囲は 10^4 ~10^5
左詰め、上詰め仮定して良い？(仮定しない場合 N^2 で計算できるが)
良い置き方はビームで求めれそう
焼きなましとかで完成形を求めて、あとはそれにする方法を考える
自身の下か右のいずれかに自身より大きいものしか存在しない平面が存在する ↑
初期の長さ決め打ちの時点で尤度は計算可能
クエリで長さの大小関係を求めるとか
ランダムに置くのが普通に強い
ランダムに多様性を持たせられると良いかも
右と下のラインんさえ管理すればよい
そうすると、ビームの遷移が √N くらいになる
ビームするときに、ぎりぎりを責めない、もしくは候補を残せるおうな探索をできるとよい
総面積と含有率から、だいたいの辺の長さの上限を決められるから、改行のタイミングとか決められる
クエリスコアは元の予想より大きいことはあっても小さいことは無い説
ビームの評価関数変えたら上手くいかんかなあ
基本的に山登りのほうが強そうだからよさげな近傍を見つけたい
左上に配置する、の近傍はあってよいかも
右端は左移動がよき
クエリの有効活用
最後の一個の置き方大事かも
右に隙間があるならそこに動かすとか
すきまに突っ込んでく貪欲
削除して過去の隙間に突っ込む近傍
近傍の種類をタイミングで分ける
回転&ベースすらし（引っ掛かりの原因になってそうなところに）
ベースずらし
ちょい右ずらしで縦の長さを減らす
大きいやつを先に詰めて、小さいやつは後で詰める（疑似的に）
いくつかに分割し、既定の横幅に制限した中で、もっとも凸凹が小さくなるような配置を求める。
ビームサーチの評価関数再考
「すきまを作らない埋め方」が良いかも
少し時間かけてでも、長さをしっかり推定した方が良いかも
複数のものをかたまりとして見て回転
シンプルな評価関数の高速化（vector使うとか
ある二列の右上と左下スワップ
多次元配列で状況を表現すれば、遷移は楽に書ける
入力と出力の制限は最後の平均取るときだけで良い
挿入じゃなくて、末尾追加＆ソートの方が早いかも