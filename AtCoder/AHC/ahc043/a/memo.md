循環線が良さげ？
一回立てた路線は生涯現役
コスパがよい順にたててよい？
何個立てれるかを二分探索？

最終形をあらかじめ決めて，それになるはやで到達する順番を求める．
全埋めできる可能性もある
置く場所を列挙したあと，置く数を減らすようにいい感じにずらしながら頑張る
あとは置く順番を焼きなます
順番さえ決めればええ感じにならないかな

序盤だけは貪欲がよいか？

順番と配置場所焼けそう？
配置決まったら，あとは路線図を決める．
waitをやめるタイミングを変更．（途中からは常に開発）

その行の駅が一個もないなら，接続する
あるなら，よこから伸ばす

焼くにしては評価関数重すぎ
一旦線路接続を考えずに焼いてみる？
もっと賢い貪欲ありそう

接続の中継にできるならOK
できないなら最短と繋ぐ，とかでO(T)で暫定評価できるかも

7500（次回に必要な分）たまった時点でのコスパ/時刻が大きいほうがよい？
駅を置く場所の候補をいい感じにしぼれればいいな

bfsしなくてよいかも
間にあるなら中継地点追加
無いなら一番近いやつと接続みたいな感じで辺の両端を管理

評価はvisitedに加算する形で管理し，差分更新できそう

ビーム打つなら頂点の選び方考える

C++に移植するだけでそこそこスコア伸びる

M個の駅を配置した時点での利得を最大化するような選び方
そもそも下位互換となるような置き方を削除するとどれだけ残るか

序盤(~1000)の単価は二次関数的に増加
1000辺りを基準に，一次関数的に増加

多点スタート

重複除去と評価関数
重めなデータでビームを適用する方法考える

bfsあたりばぐってるかも

ルートの過去改変，もしくは，最短でなくても踏むことを重視する

ビームの効果は強そう

ビームでやったことをもう一つの方にも適用したい！

ビームに含める駅の場所の候補を水増しする
need_ijの各頂点ごとに適当にスコアを付けて，含まれていないものから順に追加とかで良さそう
ビーム幅要調整（割と少なくて良いかも，どうせ重複除去がへたくそですぐに埋まっちゃうので．）
それより順番交換焼きなましが熱い？

シンプルに高速化が熱い

bitset利用の検討

chokudaiサーチの利用

ビームの改善が本線

ビーム幅調整も大事かも

焼きなましの近傍やその確率の調整

限界高速化

評価の打ち切り
簡易スコア計算

ずらして，線路をさぼれないか試す

初動のビーム幅挙げるとか？？

置く場所をちょいずらす
メリットしかないならずらしてOK

上位互換ならば，そっち使う
- 既に道上
→
    - 含有しているエリアの種類が上位互換 
- 道上ではない
→
    - 含有しているエリアの種類が同じであって，道上にある
    - 含有しているエリアの種類が上位互換 

距離が遠いかつ，近くに線路は存在する場合，そこに駅を立ててから，線路を繋いだ方が早い