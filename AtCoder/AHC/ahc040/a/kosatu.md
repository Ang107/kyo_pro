必ずしも、最初から良い置き方を探しに行く必要は無い
最初は今のアイテムの大きさの推定に徹するのもあり
こういう置き方をしたときに、得られる情報量が多いよね、というような置き方を繰り返すことで、
効率よく、それぞれの大きさを絞り、良い置き方を見つけたい
正規の値の範囲は 10^4 ~10^5
左詰め、上詰め仮定して良い？(仮定しない場合 N^2 で計算できるが)
良い置き方はビームで求めれそう
焼きなましとかで完成形を求めて、あとはそれにする方法を考える
自身の下か右のいずれかに自身より大きいものしか存在しない平面が存在する ↑
初期の長さ決め打ちの時点で尤度は計算可能
クエリで長さの大小関係を求めるとか
ランダムに置くのが普通に強い
ランダムに多様性を持たせられると良いかも
右と下のラインんさえ管理すればよい
そうすると、ビームの遷移が √N くらいになる
ビームするときに、ぎりぎりを責めない、もしくは候補を残せるおうな探索をできるとよい
総面積と含有率から、だいたいの辺の長さの上限を決められるから、改行のタイミングとか決められる
クエリスコアは元の予想より大きいことはあっても小さいことは無い説
ビームの評価関数変えたら上手くいかんかなあ
基本的に山登りのほうが強そうだからよさげな近傍を見つけたい
左上に配置する、の近傍はあってよいかも
右端は左移動がよき
クエリの有効活用
最後の一個の置き方大事かも
右に隙間があるならそこに動かすとか
すきまに突っ込んでく貪欲
削除して過去の隙間に突っ込む近傍
近傍の種類をタイミングで分ける
回転&ベースすらし（引っ掛かりの原因になってそうなところに）
ベースずらし
ちょい右ずらしで縦の長さを減らす
大きいやつを先に詰めて、小さいやつは後で詰める（疑似的に）
いくつかに分割し、既定の横幅に制限した中で、もっとも凸凹が小さくなるような配置を求める。
ビームサーチの評価関数再考
「すきまを作らない埋め方」が良いかも
少し時間かけてでも、長さをしっかり推定した方が良いかも
複数のものをかたまりとして見て回転
シンプルな評価関数の高速化（vector使うとか
ある二列の右上と左下スワップ
多次元配列で状況を表現すれば、遷移は楽に書ける
入力と出力の制限は最後の平均取るときだけで良い
挿入じゃなくて、末尾追加＆ソートの方が早いかも
ベストスコアとなるような答えがどれくらいの回数で出ているかが大事そう
なるべく、大きさ推定にクエリを割きたいが、良い答えを取り逃すリスクもある
概算スコアでの箱の含有率を求めてみる
小さいものはあとから考えるとかもあり
後で追加方法を焼く方がえらいかもしれない
極端に細いやつは後で処理(右から寄せるとか)
マージ操作（短い方の長さが閾値以下であるという条件を課す
二段階山登り(現状を初期解として、さらに改善を試みる)
サンプルをランダム生成して、期待値が高いものや、上振れが高いものを提出
ダストボックスの用意
そもそもにダストボックスに入れる要素を制限&ダストボックスへの収納の方法は簡単な貪欲
有意に小さい高さまでしか積まないようにするとか
評価関数高速化できそう
遷移増やせるかなあ
定数倍高速化頑張る
横の長さを離散ではなく連続にする
山登りで良い遷移となる確率が高そうな遷移を選ぶ

# AHC040解法

**暫定順位 20位**

主な解法: **多点スタート焼きなまし法**

## 重要な考察
- 移動方向が、上・左の二つがあるが、双方を組み合わせて使った場合、長さの大小関係が実際のものと異なった場合に事故る
- 上のみ、(もしくは左のみ)に制限することで、そういった大きな事故を防ぐことができる  
    (隙間に収めるつもりが、実際は収まらい故に高さが想定より大きくなる等は生じるが、確率はそれほど高くない)

## 解法
- スコア狙いのクエリは固定で $20$ 回
- $\max(0,T-20)$ 回は、単体の箱の大きさを聞くクエリとして、均等に割り振る
- 初期の値とクエリの返り値の平均値をその箱の大きさとする   
    (chatGPTに聞いたら、尤度が最も高くなる値 = 平均値とのことだったが本当かは不明)
- 寄与は殆どないが、箱の大きさとしては有り得る値の最小・最大値を超えないようにする
- 時間がある限り、初期盤面をランダムに生成、焼きなますことを繰り返し、良さげな答えを沢山生成する
- そのうち、暫定スコアが上位の20個について、スコア狙いのクエリを送る(暫定スコアのH, Wが共に等しいものは除去)
- スコア狙いのクエリに対する返り値は無視

### 初期盤面について
- 盤面の大きさ
- 回転の状態
- 初期の配置
をランダムに設定

### 焼きなましについて
近傍は以下の $4$ つ
- 一つの箱の回転
- 右上と左下のスワップ(ランダムに回転も行う)
- 右上から左下への移動(ランダムに回転も行う)
- 左下から右上への移動(ランダムに回転も行う)

評価関数は、O(N√N)でシミュレートして生スコアを計算。  
定数倍高速化と評価の打ち切りで高速化を頑張る。  
高速化することで、上限値(現在のコードでの理論値)は変わらないものの、安定して高スコアを出せるようになった。
