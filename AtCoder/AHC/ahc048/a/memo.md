一旦真っ新なパレットを考える
このとき，目標のベクトルは，係数が離散化された各ベクトルの和を目標値に近似することと言える

最後の一回の追加のみは係数が連続にできる可能性を秘めている ← これ難しい

また，その時点で，色の種類数をふやすのは頂けないが，かといって量が少なくなりすぎるのも良くない ← これは係数の和が 1 以上とすればよい

出来る操作が少ないケースは別で考えるか
目標の絵具を全探索(i:0~999){
使う絵の具の数の上限を 5 として，
使う絵の具の数[1,2,3,4,5]，係数[0.1,0.2,...1.1...2] を乱択する(iter=1000)
係数の和が 1 以上になるように各係数を調整
そのときの誤差，必要な絵具の量，必要な操作回数を計算
必要な操作回数が (T-1000)/1000 以下であって，
誤差と絵具の量から求められるコストが最小となるような係数列を求める
係数列を山登り(係数の増減)(iter=1000)
係数列を元に操作を構築，出力

}
使う絵の具の数のループ(cnt:1~3){
使う絵の具の種類数を全探索(20 C cnt){
使う絵の具の量の列の全探索([0.1,0.2,...1.1...2] を cnt 回直積){
そのときの誤差，必要な絵具の量，必要な操作回数を計算
必要な操作回数が (T-1000)/1000 以下であって，
誤差と絵具の量から求められるコストが最小となるような使う絵の具の量の列を求める
}
}
}

T を有効に使い切る
maxcolors=1 のケースの改善
特に絵具が高い場合，一気に作ってあとで渡すみたいなやり方が良い
最初に出すだけ出してそれを上手いこと混ぜるみたいな必要がある

乱択，山登り部分の高速化
操作の効率化

T が小さいケースの特殊ソルバー作る
↑ 一応ビムサをできる
チューブの使ってる本数調べる
離散化によるコスト増加量を調べる

特殊ソルバーに力入れてもいいかもなー
一つのウェルをでかくしていい
最初からいくつか色をいれてよい
↑ この辺は試すしかない

ウェルサイズ割り当て適当でよいか

T が大きい場合のソルバー
バイナリ敵に管理する

乱択山登り部分の評価高速化できそう
だいぶ早くなったがまだ伸びしろありそう
温度いじる，温度関数いじる
近傍いじる

乱択はあらかじめ生成しておき，その中から探すのもありか？
生成にかかるコストを減らしつつ

bit 全探索は K が大きいと重いのでその場合は乱宅を使う

計数列生成 → 各目標への距離の最短を探す(それを初期解とする)
焼きなましとか乱宅いらん
もう一つの方が早くて正確

T がある程度大きいケースについては，連続値は最適値求まっているので離散値時の誤差を頑張る作業

T が小さいものは，色々やれる．

足し合わせ先戦法が強い(同じ色で二行分割してその和でやる)
T に合わせて動的に調整可能
実装が少し難しいが，現実的かつ，確実にスコア上昇を狙える

T が小さいケースは安全択 + T が大きい用の攻めの混ぜもあり

調合するにも二行分割にしても現行のコードを整理したいかも

1000 手以降はダイレクトにコストがかかる
絵具追加無しで可能な誤差最小値を求めるような関数がほしい

特に最後の一個とかでチューブ追加なしで誤差を最低限抑えるようなムーブをしたい(影響は少ないと思う)
現状の絵具の合計が 1 以上あるときにそれらを使って

現状の貪欲をビーム化出来る

最終盤は無駄に絵具を同色で二本使うことを回避する

マージ実装するかなあ

マージ実装を前提としたビーム書くか
それとマージ以外良いアイデアが無い

まだ T をもてあますケースがあるが，良き活用方法は浮かばぬ

ビーム弱かった
残念

200(盤面変更)
200(余分の絵具注入用)
2t(追加+渡す)
19*t + 200 + 200 + 2 * (1000-t) < T
19t


捨てないという選択
余った僅かな色を受け入れて立ち回る

精度が低いものに合わせるように定数倍する

細かい最適化(特にneedidxの修正が聞きそう)

候補列挙の結果見る

単体低いやつの対策

三重ループ二重に落とせたりしないか

need_idxを必要以上に削らない作戦

二乗ループと尺取りで計算量おとせそう
それで，両方合わせて足りない場合は片方に1加算するとか良いね

エラーが出やすいケース，出にくいケースの違いis何？？
(係数の最小値の大きさだと思ったけど，そうでも無いらしい)

とりま高速化頑張るぞい

最初に全部一杯ずつ入れとくのはあり，どうせ使う

実数 $x (0 <= x <= 2)$ ,$y (0 <= 1)$ を考える。
また，正整数 $minden(1<= minden <= 200)$ ,$maxden(1<= maxden <= 200)$が与えられる。
このとき，
$x * (a_1/b_1) * (a_2/b_2) * (a_k/b_k) == y$
のように近似するようにai,biの列を求める．
k <= 1,2,3のそれぞれの場合に求めるとする。

但し，以下の条件がある
- $\sum_{i=1}^{k-1}(bi - ai) + b_k <= maxden$
- $b_1 >= minden$
- $a_i <= b_i$

